/**
 * Dataset contract version.
 *
 * Why we version:
 * - UI and BFF can evolve independently.
 * - We can reject incompatible clients early with a clear error.
 */
export const CONTRACT_VERSION = 'v1' as const;

export type ContractVersion = typeof CONTRACT_VERSION;

/**
 * Dataset identifier.
 *
 * Think of this as "which dataset to query" (like an API resource name),
 * not "which widget". Widgets *choose* a datasetId.
 *
 * Examples:
 * - "payment.kpi"
 * - "payment.timeseriesDaily"
 */
export type DatasetId = string;

export type JsonPrimitive = string | number | boolean | null;
export type JsonValue = JsonPrimitive | JsonValue[] | { [key: string]: JsonValue };

/**
 * DatasetQuery is the ONLY input format the UI sends to the BFF.
 *
 * Important design goals:
 * - **Stable**: widgets only know this shape, not SQL, not Oracle, not Cube.
 * - **Cache-friendly**: can be used to build cache keys.
 * - **Portable**: the server can compile this into different backends.
 */
export type DatasetQueryV1 = {
	contractVersion: ContractVersion;
	/**
	 * Optional request identifier for tracing/dedup/debug.
	 * Should be generated by the caller; server may echo it back.
	 */
	requestId?: string;
	/**
	 * Global filters snapshot (typically produced by `entities/filter`).
	 *
	 * We keep filters inside the query so the BFF can stay stateless and
	 * the cache key can be derived from a single input object.
	 *
	 * NOTE: tenant/user context should NOT be put here; it belongs to server ctx.
	 */
	filters?: Record<string, JsonValue>;
	/**
	 * Dataset-specific parameters (widget config etc).
	 * This is intentionally opaque to keep widgets decoupled from providers.
	 */
	params?: Record<string, JsonValue>;
};

export type DatasetQuery = DatasetQueryV1;

export type DatasetFieldType = 'string' | 'number' | 'boolean' | 'date' | 'datetime' | 'json' | 'unknown';

export type DatasetField = {
	name: string;
	type: DatasetFieldType;
	nullable?: boolean;
};

/**
 * DatasetResponse is the ONLY output format the BFF returns to the UI.
 *
 * `rows` is intentionally generic (Record<string, JsonValue>) so:
 * - providers can return what makes sense for the dataset
 * - UI can map it into view-models (charts/tables)
 *
 * Later you can tighten this per-dataset by adding a registry layer,
 * but for MVP this keeps wiring simple.
 */
export type DatasetResponseV1 = {
	contractVersion: ContractVersion;
	datasetId: DatasetId;
	requestId?: string;
	fields: DatasetField[];
	rows: Array<Record<string, JsonValue>>;
	meta?: {
		executedAt?: string;
		tenantId?: string;
		source?: 'mock' | 'oracle' | 'postgres' | 'cube' | 'unknown';
	};
};

export type DatasetResponse = DatasetResponseV1;


